sp {topstate*elaborate*game-state-input
   (state <s> ^superstate nil
              ^world.predicates <ps>
              ^io.input-link.game-state <gs>)
   (<gs> ^objects <obsj> ^relationships.prep <rels>)# ^turn <n>)
   (<rels> ^name <name>)
-->
   (<ps> ^predicate <p>)
   (<p> ^handle <name>)
}

sp {topstate*elaborate*game-state-input*predicate*instance
   (state <s> ^superstate nil
              ^world.predicates <ps>
              ^io.input-link.game-state <gs>)
   (<gs> ^objects <objs> ^relationships.prep <rels>)# ^turn <n>)
   (<objs> ^object <o1> <o2>)
   (<rels> ^name <name> ^pair <pa>)
   (<ps> ^predicate <p>)
   (<p> ^handle <name>)
   (<o1> ^id <id1>)
   (<o2> ^id <id2>)
   (<pa> ^|1| <id1> ^|2| <id2>)
-->
    (<p> ^instance <i>)
    (<i> ^1 <o1> ^2 <o2>)
}

sp {topstate*elaborate*game-state-input*object
   (state <s> ^superstate nil
              ^world.objects <objs>
              ^io.input-link.game-state <gs>)
   (<gs> ^objects.object <obj> ^relationships <rels>)# ^turn <n>)
-->
    (<objs> ^object <obj>)
   (<obj> ^category block ^primitive object)
}


sp {satisfy-predicate-conditions*propose*predicate-operator*goal
    (state <s1> ^gtype { << goal >> <c2> } ^list <l1> ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^aname <c1>)
    (<p1> ^set <i1>)
    -->
    (<s1> ^operator <o1> + > =)
    (<o1> ^type <c2> + ^name <c1> + ^parameters <i1> +)
}

sp {satisfy-predicate-conditions*propose*predicate-operator*failure
    (state <s1> ^gtype { << failure >> <c2> } ^list <l1> ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^aname <c1>)
    (<p1> ^set <i1>)
    -->
    (<s1> ^operator <o1> + > =)
    (<o1> ^type <c2> + ^name <c1> + ^parameters <i1> +)
}

sp {satisfy-predicate-conditions*propose*predicate-operator*action*heuristic
    (state <s1> ^gtype { << action >> <c2> } ^list <l1> ^<c2> <a1> ^main-type heuristic)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^aname <c1> ^verb-structure <vs>)
    (<p1> ^set <i1>)
    -{(<s1> ^heuristic.condition <con>)
      (<con> -^result.set.instance)}
    -->
    (<s1> ^operator <o1> +)
    (<o1> ^type <c2> + ^name <c1> + ^parameters <i1> + ^verb-structure <vs>)
}
sp {satisfy-predicate-conditions*propose*predicate-operator*action
    (state <s1> ^gtype { << action >> <c2> } ^list <l1> ^<c2> <a1> -^main-type heuristic -^main-type predicate)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^aname <c1> ^verb-structure <vs>)
    (<p1> ^set <i1>)
    -->
    (<s1> ^operator <o1> +)
    (<o1> ^type <c2> + ^name <c1> + ^parameters <i1> + ^verb-structure <vs>)
}

sp {satisfy-predicate-conditions*propose*finished-learning-predicate
    (state <s1> ^main-type predicate 
                ^gtype predicate 
                ^list <l1> 
                ^predicate <a1>
                ^top-state.dialog-context <dc>)
    (<dc> ^learn-link.handle <c1> ^learning true)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^handle <c1>)
    (<p1> ^set <i1>)
    -->
#(write (cmd print <i1> -d 4))
    (<s1> ^operator <o1> + =)
    (<o1> ^name finished-learning-predicate)
  #  (<s1> ^operator <o1> + =)
  #  (<o1> ^name finished-learning
  #        ^type predicate)
}

sp {satisfy-predicate-conditions*elaborate-finished-learning*predicate
    (state <s1> ^top-state.dialog-context.learning true ^superstate <ss>)
    (<s1> ^main-type {<type> << predicate >>} ^operator <o>)# ^<type> <a1>)
    (<o> ^name finished-learning-predicate) 
   # (<a1> ^parameter-set <p1> ^handle <c1>)
    #(<p1> ^set <i1>)
    -->
    (<ss> ^finished-learning <type>)
}

sp {satisfy-predicate-conditions*elaborate-finished-learning
    (state <s1> ^top-state.dialog-context.learning true ^superstate <ss>)
    (<s1> ^main-type {<type> << action >>} ^operator <o> ^<type> <a1>)
    (<o> ^type <type> -^duplicate-of) 
    (<a1> ^parameter-set <p1> ^handle <c1>)
    (<p1> ^set <i1>)
    -->
    (<ss> ^finished-learning <type>)
}

sp {satisfy-predicate-conditions*elaborate-finished-learning*heuristic
    (state <s1> ^top-state.dialog-context.learning true ^superstate <ss>)
    (<s1> ^main-type {<type> << heuristic >>} ^operator <o> ^<type> <a1>)
    (<o> ^type action -^duplicate-of) 
    (<a1> ^parameter-set <p1> ^handle <c1>)
    (<p1> ^set <i1>)
    -->
    (<ss> ^finished-learning <type>)
}

sp {satisfy-predicate-conditions*elaborate-finished-learning*goal
    (state <s1> ^top-state.dialog-context.learning true ^superstate.superstate <sss> ^superstate <ss>)
    (<s1> ^main-type {<type> << goal failure >>} ^operator <o> ^<type> <a1>)
    (<o> ^type <type> -^duplicate-of) 
    (<a1> ^parameter-set <p1> ^handle <c1>)
    (<p1> ^set <i1>)
    -->
#(write (cmd print <i1> -d 4))
    (<sss> ^finished-learning <type>)
    (<ss> ^finished-learning <type>)
}

 # TODO need deep-copy here?
sp {satisfy-predicate-conditions*apply*finished-learning*elab-store-link
    (state <s1> ^top-state.dialog-context.learning true
                ^top-state.dialog-context.learn-link <ll>
                ^operator.name finished-learning)
    (<ll> ^predicate-structure)
-->
    (<s1> ^store-link (deep-copy <ll>))
}

sp {satisfy-predicate-conditions*apply*finished-learning*elaborate*source
    (state <s1> ^top-state.dialog-context <dc>
                ^store-link <ll>
                ^operator.name finished-learning)
    (<dc> ^learning true ^name <name>)
-->
    (<ll> ^from <name>)
}

#HACK TO FIX MIRROR JUSTIFICATTION PROBLEM 
sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance
    (state <s1> ^top-state.dialog-context.learning true
                ^store-link <ll>
                ^operator.name finished-learning)
    (<ll> ^predicate-structure.conditions <c>)
    (<c> ^result.set <res> -^name number)
    (<res> ^instance <i>)
-->
    (<res> ^instance <i> -)
}

sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance2
    (state <s1> ^top-state.dialog-context.learning true
                ^store-link <ll>
                ^operator.name finished-learning)
    (<ll> ^predicate-structure.conditions.args.<n> <c>)
    (<c> ^result.set <res> -^name number)
    (<res> ^instance <i>)
-->
    (<res> ^instance <i> -)
}

sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance3
    (state <s1> ^top-state.dialog-context.learning true
                ^store-link <ll>
                ^operator.name finished-learning)
    (<ll> ^predicate-structure.conditions.args.<n>.args.<n1> <c>)
    (<c> ^result.set <res> -^name number)
    (<res> ^instance <i>)
-->
    (<res> ^instance <i> -)
}

sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance4
    (state <s1> ^top-state.dialog-context.learning true
                ^store-link <ll>
                ^operator.name finished-learning)
    (<ll> ^predicate-structure.conditions.args.<n>.args.<n1>.args.<n2> <c>)
    (<c> ^result.set <res> -^name number)
    (<res> ^instance <i>)
-->
    (<res> ^instance <i> -)
}

sp {satisfy-predicate-conditions*apply*finished-learning*remove-instance5
    (state <s1> ^top-state.dialog-context.learning true
                ^store-link <ll>
                ^operator.name finished-learning)
    (<ll> ^predicate-structure.conditions.args.<n>.args.<n1>.args.<n2>.args.<n3> <c>)
    (<c> ^result.set <res> -^name number)
    (<res> ^instance <i>)
-->
    (<res> ^instance <i> -)
}

sp {finished-learning*store*predicate*concept
   (state <s> ^name finished-learning    
              ^smem.command <sc>
              ^superstate.store-link <ll>)
-->
    (<s> ^store-link <ll>)
    (<s> ^to-store <ll>)
   (<sc> ^store <ll>)
}

sp {finished-learning*propose*store*primary*rtype
   (state <s> ^operator.name finished-learning
              ^store-link <ll>)
   (<ll> ^predicate-structure.conditions.parameter.<num> <p>)
   (<p> ^param-id 1 ^type <rtype>)
-->
   (<ll> ^primary-rtype <rtype>)
}

sp {finished-learning*propose*store-next-level
   (state <s> ^name finished-learning
             -^all-stored
              ^store-link <ts>)
-->
   (<s> ^operator <o> + =)
   (<o> ^name store-game-level
        ^to-store <ts>)
}
sp {finished-learning*apply*store-next-level*finished
   (state <s> ^name finished-learning
              ^operator <o>)
   (<o> ^name store-game-level)
   -{(<s> ^to-store.<something> {<t2> <=> <s>})
    -{(<s> ^to-store <t2>)}}
-->
   (<s> ^all-stored true)
}
sp {finished-learning*apply*store-next-level2
   (state <s> ^name finished-learning
              ^operator <o>
              ^to-store <ts>
              ^smem.command <sc>)
   (<o> ^name store-game-level)
   (<ts> ^{<something> <> final <> goal-state <> initial } {<something2> <=> <s>})
-->
   (<s> ^to-store <something2>)
   (<sc> ^store <something2>)
}

sp {finished-learning*propose*complete
   (state <s> ^name finished-learning)
-->
   (<s> ^operator <o> + <)
   (<o> ^name complete)
}

#sp {finished-learning*apply*complete*remove-learn-link
#    (state <s1> ^name finished-learning
#                ^operator.name complete
#                ^top-state.dialog-context <dc>)
#    (<dc> ^store-learn-link <ll> ^learn-link {<l2> <> <ll>})
#-->
#(interrupt)
# #   (<dc> ^store-learn-link <ll> -)
# #  (<dc> ^learn-link <ll>)
# #  (<dc> ^learn-link <l2> -)
#}

sp {satisfy-purpose*finished-learning*apply*complete*remove-learn-link
    (state <s1> ^name interaction
                ^operator <o>
               -^top-state.new-spelling #HACKy
                ^top-state.dialog-context <dc>)
    (<dc> ^learn-link <ll>)
    (<ll> ^argnum <a>) #means built
    (<o> ^name performed-event
         -^event.learning-event.type game-name
         -^event.dialog-event.type process-unknown-word
        -^event.dialog-event.type process-sentence)
-->
   (<dc> ^learn-link <ll> -)
}

sp {interaction*apply*performed-event*game-learning*clean*dialog-object-list
    (state <s1> ^name interaction
                ^top-state <top>
                ^operator <o>)
    (<o> ^name performed-event
         ^event.learning-event.type game)
    (<top> ^dialog-world <w> ^dialog-object-list <list> ^dialog-object-list-saved <dls>)
-->
  (<top> ^dialog-object-list <list> -
         ^dialog-world <w> -
         ^dialog-object-list-saved <dls> -
         ^dialog-object-list nil
         ^dialog-object-list-saved nil
         ^dialog-world <new>)
  (<new> ^objects <objs> ^predicates <preds>)
}

sp {satisfy-purpose*clean*dialog-object-list
    (state <s1> ^name satisfy-purpose
                ^operator.name wait-for-response
                ^top-state <ts>)
    (<ts> ^dialog-object-list {<dol> <=> <s1>})
-->
   (<ts> ^dialog-object-list <dol> -)
   (<ts> ^dialog-object-list nil)
}

sp {satisfy-purpose*clean*dialog-object-list-saved
    (state <s1> ^name satisfy-purpose
                ^operator.name wait-for-response
                ^top-state <ts>)
    (<ts> ^dialog-object-list-saved {<dol> <=> <s1>})
-->
   (<ts> ^dialog-object-list-saved <dol> -)
   (<ts> ^dialog-object-list-saved nil)
}

sp {satisfy-purpose*clean*dialog-world
    (state <s1> ^name satisfy-purpose
                ^operator.name wait-for-response
                ^top-state <ts>)
    (<ts> ^dialog-world.<< objects predicates >> <dw>)
    (<dw> ^<something> <obj>)
-->
   (<dw> ^<something> <obj> -)
}


#sp {finished-learning*apply*complete*output-object-1
#    (state <s1> ^name finished-learning
#                ^operator.name complete
#                ^top-state.dialog-context <dc>)
#    (<dc> ^output-object-1 <lp>)
#-->
#    (interrupt)
#   #(<dc> ^output-object-1 <lp> -)
#}
#sp {finished-learning*apply*complete*input-object-1
#    (state <s1> ^name finished-learning
#                ^operator.name complete
#                ^top-state.dialog-context <dc>)
#    (<dc> ^input-object-1 <lp>)
#-->
#   (<dc> ^input-object-1 <lp> -)
#}
#sp {finished-learning*apply*complete*input-object-2
#    (state <s1> ^name finished-learning
#                ^operator.name complete
#                ^top-state.dialog-context <dc>)
#    (<dc> ^input-object-2 <lp>)
#-->
#   (<dc> ^input-object-2 <lp> -)
#}


#learn chunk right away like for actions
#sp {finished-learning*apply*complete*send-message*predicate
#    (state <s1> ^name finished-learning
#                ^operator.name complete
#                ^top-state.dialog-context <dc>
#                ^top-state.interaction.status <status>
#                ^top-state.interaction.changes <changes>)
#    (<dc> ^learning-predicate <lp> ^learn-link.handle <word>)
#    (<lp> ^name <word>)
#-->
#   (<dc> ^learning-predicate <lp> -)
#   (<changes> ^outgoing-message <msg>)
#   (<msg> ^type learned-unknown-word
#          ^complete-message true
#          ^fields.word <word>)
#   (<status> ^performed.learning-event <de>)
#   (<de> ^type game
#         ^originator agent)
#}

sp {finished-learning*apply*complete*predicate*create-temp-dummy-action
    (state <s1> ^name finished-learning
                ^operator.name complete
                ^superstate <ss>
                ^store-link <sl>
                ^top-state.dialog-context <dc>)
    (<dc> ^learning-predicate.name <name>)
    (<sl> ^handle <name>)
-->
(<ss> ^gtype action ^action <a>)
(<a> ^condition <c>)
(<c> ^name <name> ^type concept ^attribute predicate)
}
    
sp {finished-learning*apply*complete*send-message*predicate
    (state <s1> ^name finished-learning
                ^operator.name complete
                ^store-link <sl>
                ^top-state.dialog-context <dc>)
    (<dc> ^learning-predicate.name <name>)
    (<sl> ^handle <name>)
-->
   (<dc> ^finalize-chunk <name>)
}

sp {finished-learning*apply*complete*send-message*heuristic
    (state <s1> ^name finished-learning
                ^operator.name complete
                ^store-link <sl>
                ^top-state.dialog-context <dc>)
    (<dc> ^structure.heuristics <act> -^learning-predicate)
    (<sl> ^handle <name> ^ntype heuristic)
-->
   (<act> ^retrieve-handle <name>)
   (<dc> ^finalize-chunk <name>)
}

sp {finished-learning*apply*complete*send-message*action
    (state <s1> ^name finished-learning
                ^operator.name complete
                ^superstate <ss>
                ^top-state.dialog-context <dc>)
    (<dc> ^structure.actions <act> -^learning-predicate)
    (<act> ^action <a>)
    (<a> ^handle <name>)
-->
   (<act> ^action <a> -)
   (<act> ^retrieve-handle <name>)
   (<dc> ^finalize-chunk <name>)
}

#sp {finished-learning*apply*complete*send-message*heuristic*copied
#    (state <s1> ^name finished-learning
#                ^top-state <ts>
#                ^operator.name complete
#                ^top-state.dialog-context <dc>
#                ^top-state.interaction.status <status>
#                ^top-state.interaction.changes <changes>)
#    (<dc> ^structure.heuristics <act> -^learning-predicate ^learn-link.handle <name>)
#    (<act> -^heuristic <a>)
#    (<ts> ^new-spelling <ns>)
#    #(<a> ^handle <name>)
#-->
##(<ts> ^new-spelling <ns> -)
#   (<act> ^retrieve-handle <name>)
#   (<dc> ^finalize-chunk <name>)
#}
sp {finished-learning*apply*complete*send-message*action*copied
    (state <s1> ^name finished-learning
                ^top-state <ts>
                ^operator.name complete
                ^top-state.dialog-context <dc>
                ^top-state.interaction.status <status>
                ^top-state.interaction.changes <changes>)
    (<dc> ^structure.actions <act> -^learning-predicate ^learn-link <ll>)
    (<ll> ^handle <name> ^type action)
    (<act> -^action <a>)
    (<ts> ^new-spelling <ns>)
    #(<a> ^handle <name>)
-->
#(<ts> ^new-spelling <ns> -)
   (<act> ^retrieve-handle <name>)
   (<dc> ^finalize-chunk <name>)
}
sp {finished-learning*apply*complete*send-message*failure*copied
#:interrupt
    (state <s1> ^name finished-learning
                ^top-state <ts>
                ^operator.name complete
                ^top-state.dialog-context <dc>
                ^top-state.interaction.status <status>
                ^top-state.interaction.changes <changes>)
    (<dc> ^structure.failures <act> -^learning-predicate ^learn-link <ll>)
    (<ll> ^handle <name> ^type failure)# ^type failure)
    (<act> -^failure <a>)
    (<ts> ^new-spelling <ns>)
    #(<a> ^handle <name>)
-->
#(<ts> ^new-spelling <ns> -)
   (<act> ^retrieve-handle <name>)
   (<dc> ^finalize-chunk <name>)
}

#JK copy issue fixed til here!!!
sp {finished-learning*apply*complete*send-message*goal*copied
#:interrupt
    (state <s1> ^name finished-learning
                ^top-state <ts>
                ^operator.name complete
                ^top-state.dialog-context <dc>
                ^top-state.interaction.status <status>
                ^top-state.interaction.changes <changes>)
    (<dc> ^structure.goals <act> -^goal-relationships -^learning-predicate ^learn-link <ll>)
    (<ll> ^handle <name> ^type goal)
    (<act> -^goal <a>)
    (<ts> ^new-spelling <ns>)
    #(<a> ^handle <name>)
-->
#(<ts> ^new-spelling <ns> -)
   (<act> ^retrieve-handle <name>)
   (<dc> ^finalize-chunk <name>)
}

sp {finished-learning*apply*complete*send-message*goal
    (state <s1> ^name finished-learning
                ^operator.name complete
                ^top-state.dialog-context <dc>
                ^top-state.interaction.status <status>
                ^top-state.interaction.changes <changes>)
    (<dc> ^structure.goals <act> -^goal-relationships -^learning-predicate)
    (<act> ^goal <a>)
    (<a> ^handle <name>)
-->
   (<act> ^goal <a> -)
   (<act> ^retrieve-handle <name>)
   (<dc> ^finalize-chunk <name>)
}

sp {finished-learning*apply*complete*send-message*failure
    (state <s1> ^name finished-learning
                ^operator.name complete
                ^top-state.dialog-context <dc>
                ^top-state.interaction.status <status>
                ^top-state.interaction.changes <changes>)
    (<dc> ^structure.failures <act> -^learning-predicate)
    (<act> ^failure <a>)
    (<a> ^handle <name>)
-->
   (<act> ^failure <a> -)
   (<act> ^retrieve-handle <name>)
   (<dc> ^finalize-chunk <name>)
}

sp {finished-learning*apply*complete*send-message*goal-state*demo
    (state <s1> ^name finished-learning
                ^operator.name complete
                ^top-state.dialog-context <dc>
                ^top-state.interaction.status <status>
                ^top-state.interaction.changes <changes>)
    (<dc> ^structure.goals <act> ^goal-relationships <gs> ^attend <at>)
    (<act> ^goal <a>)
    (<a> ^handle <name>)
-->
   (<act> ^goal <a> -)
   (<dc> ^attend <at> -)
   (<act> ^retrieve-handle <name>)
   (<changes> ^outgoing-message <msg>)
   (<msg> ^type describe-final-goal-state
          ^complete-message true
          ^fields <f>)
   (<f> ^relationships <gs> ^definitive no)
   (<status> ^performed.learning-event <de>)
   (<de> ^type game
         ^originator agent)
}

#hmmm TODO should be chunking this? especially when considering negatives


#negative learned predicate copies
#for single param (all same return type) need to add single to set and set to single, etc
#should work for 2 param indef or single (clear, etc)
sp {satisfy-predicate-conditions*elaborate*condition-instance*negative
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^args <ar1> ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype <type> ^negative true ^parameter <p1>)
    (<p1> ^num < 2 )
    (<ar1> ^1 <c8>)
    (<c8> ^rtype <type> ^result <r5>)
    (<r5> ^set <r52>)
    (<r52> ^instance <i1>)
    (<i1> ^1 <n4>)
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^link <c4> ^primary-rtype <type> ^parameter-set.tested calculate6)#TODO bad that relies on atleast one being calculated to know complete inorder to avoid premature negative
    (<n1> ^aname <c2>) 
 -{ (state <s1>)
    (<t1> -^instance)} 
 -{ (<t1> ^instance <i3>)
      (<i3> ^1 <n4> )
      #(<c5> ^result <r*2>)
      #(<r*2> ^set <s*4>)
      #(<s*4> ^instance <i*2>)
      #(<i*2> ^1 <objb>)
      }
    -->
    (<s2> ^instance <i5> +)
    (<i5> ^1 <n4>)
}
sp {satisfy-predicate-conditions*elaborate*condition-instance*negative*2param
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^args <ar1> ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype <type> ^negative true ^parameter <p1>)
    (<p1> ^num 2)
    (<ar1> ^1 <c8> ^2 <c9>)
    (<c8> ^rtype <type> ^result <r5>)
    (<c9> ^rtype <type> ^result <r7>)
    (<r5> ^set <r52>)
    (<r52> ^instance <i1>)
    (<i1> ^1 <n4>)
    (<r7> ^set <r72>)
    (<r72> ^instance <i7>)
    (<i7> ^1 {<> <n4> <n7>})
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^link <c4> ^primary-rtype <type> ^parameter-set.tested calculate6)    
    (<n1> ^aname <c2>)
 -{ (state <s1>)
    (<t1> -^instance)} 
 -{ (<t1> ^instance <i3>)
      (<i3> ^1 <n4> ^2 <n7>)
      #(<c5> ^result <r*2>)
      #(<r*2> ^set <s*4>)
      #(<s*4> ^instance <i*2>)
      #(<i*2> ^1 <objb>)
      }
    -->
    (<s2> ^instance <i5> +)
    (<i5> ^1 <n4> ^2 <n7>)
}


#check same primary return type (in future need to deal with different param usage of concepts)
sp {satisfy-predicate-conditions*elaborate*condition-instance
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype <rtype> ^negative false)
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^instance <i1> ^link <c4> ^primary-rtype <rtype>)
    (<n1> ^aname <c2>)
    -->
    (<s2> ^instance <i1> +)
}
#TODO analyze should try to learn these rules?????

#when child argument was a parameter and a set
sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set*parameters
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^negative false ^parameter.{1}.param-id <pid> ^args.{1} <arg> ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype set ^parameter.num < 2) # 1
    (<arg> ^rtype set ^parameter.{1}.param-id <pid> ^result.set.instance.{1} <set>)
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^link <c4> ^primary-rtype single)#^instance <i1> 
    (<n1> ^aname <c2>)
    -{(state <s1>)
     (<set> -^<something>)}
   -{(<set> ^object <obj>)
    -{(<t1> ^instance <i1>)
      (<i1> ^1 <obj>)}}
    -->
    (<s2> ^instance <i1>)
    (<i1> ^1 <set>)
}
#causes duplicate results...
#could try bias that take lowest instance with 2 as arg...
sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set*parameters2
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^negative false ^parameter.{1}.param-id <pid> ^parameter.{2}.type single ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype set ^parameter.num 2)
   #^args.{1} <arg> 
    # (<arg> ^rtype single)
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^link <c4> ^primary-rtype single ^instance <i1> )
    (<i1> ^2 <obj>)
    (<n1> ^aname <c2>)
   -{(<t1> ^instance {<is1> > <i1>}) #bias for no duplicate results
     (<is1> ^2 <obj>)}
    -->
    (<s2> ^instance <ir>)
    (<ir> ^1 <setn> ^2 <obj>)
}
sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set*parameters2*copy-objects
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^negative false ^parameter.{1}.param-id <pid> ^parameter.{2}.type single ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype set ^parameter.num 2)
   #^args.{1} <arg> 
    # (<arg> ^rtype single)
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^link <c4> ^primary-rtype single ^instance <i1> )
    (<i1> ^1 <obj1> ^2 <obj>)
    (<n1> ^aname <c2>)
    (<s2> ^instance <ir>)
    (<ir> ^1 <setn> ^2 <obj>)
-->
    (<setn> ^<object> <obj1>)
}

#only if one main parameter
sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^negative false ^args.{1}.parameter.num 0 ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype set ^parameter.num < 2) # 1
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^link <c4> ^primary-rtype single)#^instance <i1> 
    (<n1> ^aname <c2>)
    -{(state <s1>)
     (<t1> -^instance)}
    -->
    (<s2> ^instance <i1>)
    (<i1> ^1 <set>)
}

sp {satisfy-predicate-conditions*elaborate*condition-instance*single-to-set*copy-objects
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^<c1> <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^negative false ^args.{1}.parameter.num 0 ^type concept ^result <r1> ^name <c2> ^attribute <c1> ^rtype set ^parameter.num < 2) # 1
    (<r1> ^set.instance.{1} <set>)
    (<t1> ^nlp-set <n1> ^instance.{1} <obj> ^link <c4> ^primary-rtype single)
    (<n1> ^aname <c2>)
    -->
    (<set> ^<object> <obj>)
}

#any/generic action
sp {satisfy-predicate-conditions*elaborate*condition-instance*action*any
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^action <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^type concept ^result <r1> ^name any ^attribute action)
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^instance <i1>)# ^link <c4>)
   # (<n1> ^aname <c2>)
    -->
    (<s2> ^instance <i1> +)
}

sp {satisfy-predicate-conditions*elaborate*condition-instance*action #TODO fix no link issue
    (state <s1> ^gtype <c3> ^list <l1> ^<c3> <a1> ^action <t1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c4>)
    (<c4> ^type concept ^result <r1> ^name <c2> ^attribute action)
    (<r1> ^set <s2>)
    (<t1> ^nlp-set <n1> ^instance <i1>)# ^link <c4>)
    (<n1> ^aname <c2>)
    -->
    (<s2> ^instance <i1> +)
}
#Assuming just using the verb-structure and directly moved as arguments
# different once use place instead of move
sp {satisfy-predicate-conditions*action*results
    (state <s> ^<gt> <p> ^action <t> ^list <l1> ^gtype action ^gtype { <gt> << heuristic predicate goal >>})# heuristic)#^ntype heuristic 
    (<p> ^condition <c>)
    (<c> ^type concept ^attribute action ^verb <verb> ^name <name>
          ^result <r1>)
    (<t> ^verb-structure <v1> ^instance <in>)
    (<v1> ^1 <vs>)
    (<vs> ^verb-prep <verb> ^verb-name <name>)
    (<r1> ^set <rset>)
    -->
    (<rset> ^instance <in> +)
}
sp {satisfy-predicate-conditions*action-predicate*results
    (state <s> ^predicate <p> ^action <t> ^list <l1> ^gtype action)#may cause issues ^main-type predicate)#^ntype heuristic 
    (<p> ^condition <c>)
    (<c> ^type concept ^attribute action ^verb <verb> ^name <name>
          ^result <r1>)
    (<t> ^verb-structure <v1> ^instance <in>)
    (<v1> ^1 <vs>)
    (<vs> ^verb-prep <verb> ^verb-name <name>)
    (<r1> ^set <rset>)
    -->
    (<rset> ^instance <in> +)
}

sp {satisfy-predicate-conditions*action*results*no-verb
    (state <s> ^heuristic <p> ^action <t> ^list <l1> ^gtype action heuristic)#^ntype heuristic
    (<p> ^condition <c>)
    (<c> ^type concept ^attribute action -^verb ^name <name>
          ^result <r1>)
    (<t> ^verb-structure <v1> ^instance <in>)
    (<v1> ^1 <vs>)
    (<vs> ^verb-name <name>) #verb-prep
    (<r1> ^set <rset>)
    -->
    (<rset> ^instance <in> +)
}

##TODO may not need this once we have ewave working
sp {satisfy-predicate-conditions*elaborate*calculate6
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate5 ^tested calculate4)
    -->
    (<p2> ^tested calculate6 +)
}

sp {satisfy-predicate-conditions*elaborate*calculate5
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate4 ^tested calculate3)
    -->
    (<p2> ^tested calculate5 +)
}

sp {satisfy-predicate-conditions*elaborate*calculate4
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate3 ^tested calculate2)
    -->
    (<p2> ^tested calculate4 +)
}

#sp {satisfy-predicate-conditions*elaborate*calculate3
#    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
#    (<l1> ^game <g1>)
#    (<a1> ^parameter-set <p2> ^potential-args <p1>)
#    (<p2> ^tested calculate2 ^tested calculate1)
#    -->
#    (<p2> ^tested calculate3 +)
#}
#
sp {satisfy-predicate-conditions*elaborate*calculate2
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate1)
    -->
    (<p2> ^tested calculate2 calculate3)
}

#sp {satisfy-predicate-conditions*elaborate*calculate23456
#    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
#    (<l1> ^game <g1>)
#    (<a1> ^parameter-set <p2> ^potential-args <p1>)
#    (<p2> ^tested calculate3)
#    -->
#    (<p2> ^tested calculate4 calculate5 calculate6)
#}

#test that all conditions have an instance with a result
sp {satisfy-predicate-conditions*elaborate*calculate1
    (state <s1> ^simulated true ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^potential-args <p1> ^parameter-set <p2>)
    -{(state <s1>)
      (<p1> -^<asdf>)}
    -{(<a1> ^condition <c>)
      (<c> ^result.set <rset> ^return-type number)
     -{(<rset> ^instance.{1})}}
   -{(<a1> ^condition <c2>)
      (<c2> ^result.set <rset2> -^return-type number)
     -{(<rset2> ^instance.{1}.<elem>)}}
    -->
    (<p2> ^tested calculate1 +)
}

sp {satisfy-predicate-conditions*elaborate*instance*from-predicate-results
    (state <s1> ^gtype predicate ^predicate <p1> ^list <l1>)
    (<p1>  ^parameter-set <p2> ^potential-args <p3>)
    (<p2>  ^tested calculate5 ^tested calculate2
          ^tested calculate6 ^tested calculate1 ^set <s2>)
    (<l1> ^game <g1>)
    -->
    (<p1> ^instance <s2> +)
}

sp {satisfy-predicate-conditions*elaborate*result*set
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate5 ^tested calculate3 ^tested calculate2
          ^tested calculate6 ^tested calculate4 ^tested calculate1 ^iset <i1>)
   -{ (<p2> ^neg <neg1>)
      (<neg1> ^<ind4> <obj3>)
      (<i1> ^<ind4> <obj3>)}
   -{ (<p2> ^negpair3 <pair3>)
      (<pair3> ^<ind3> <objc> ^{ <> <ind3> <ind2> } <objb>
            ^{ <> <ind3> <> <ind2> <ind1> } <obja>)
      (<i1> ^<ind3> <objc> ^<ind2> <objb> ^<ind1> <obja>)}
   -{ (<p2> ^negpair <pair>)
      (<pair> ^<ind2> <objb> ^{ <> <ind2> <ind1> } <obja>)
      (<i1> ^<ind2> <objb> ^<ind1> <obja>)}
   -{ (<i1> ^<ind1> { <=> <i1> <obja> } ^<ind1> <obja>
            ^{ <> <ind1> <ind2> } <obja>)}
    -->
    (<p2> ^set <i1> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*3-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 3)
    (<p1> ^3 <o3> ^2 <o2> ^1 <o1>)
  -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^2 <o2>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^1 <o1> ^3 <o3>)}
-{ (<p2> ^negpair <pair8>)
      (<pair8> ^2 <o2> ^3 <o3>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*2-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 2)
    (<p1> ^2 <o2> ^1 <o1>)
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^2 <o2>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^1 <o1> + ^2 <o2> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*5-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 5)
    (<p1> ^5 <o5> ^4 <o4> ^3 <o3> ^2 <o2> ^1 <o1>)
  -{ (<p2> ^neg <n5>)
      (<n5> ^5 <o5>)}
  -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
  -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^2 <o2>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^1 <o1> ^3 <o3>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^1 <o1> ^4 <o4>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^1 <o1> ^5 <o5>)}
-{ (<p2> ^negpair <pair8>)
      (<pair8> ^2 <o2> ^3 <o3>)}
-{ (<p2> ^negpair <pair9>)
      (<pair9> ^2 <o2> ^4 <o4>)}
-{ (<p2> ^negpair <pair10>)
      (<pair10> ^2 <o2> ^5 <o5>)}
-{ (<p2> ^negpair <pair14>)
      (<pair14> ^3 <o3> ^4 <o4>)}
-{ (<p2> ^negpair <pair15>)
      (<pair15> ^3 <o3> ^5 <o5>)}
-{ (<p2> ^negpair <pair21>)
      (<pair21> ^4 <o4> ^5 <o5>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^5 <o5> + ^4 <o4> + ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*6-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 6)
    (<p1> ^6 <o6> ^5 <o5> ^4 <o4> ^3 <o3> ^2 <o2> ^1 <o1>)
  -{ (<p2> ^neg <n6>)
      (<n6> ^6 <o6>)}
  -{ (<p2> ^neg <n5>)
      (<n5> ^5 <o5>)}
  -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
  -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^2 <o2>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^1 <o1> ^3 <o3>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^1 <o1> ^4 <o4>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^1 <o1> ^5 <o5>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^1 <o1> ^6 <o6>)}
-{ (<p2> ^negpair <pair8>)
      (<pair8> ^2 <o2> ^3 <o3>)}
-{ (<p2> ^negpair <pair9>)
      (<pair9> ^2 <o2> ^4 <o4>)}
-{ (<p2> ^negpair <pair10>)
      (<pair10> ^2 <o2> ^5 <o5>)}
-{ (<p2> ^negpair <pair11>)
      (<pair11> ^2 <o2> ^6 <o6>)}
-{ (<p2> ^negpair <pair14>)
      (<pair14> ^3 <o3> ^4 <o4>)}
-{ (<p2> ^negpair <pair15>)
      (<pair15> ^3 <o3> ^5 <o5>)}
-{ (<p2> ^negpair <pair16>)
      (<pair16> ^3 <o3> ^6 <o6>)}
-{ (<p2> ^negpair <pair21>)
      (<pair21> ^4 <o4> ^5 <o5>)}
-{ (<p2> ^negpair <pair22>)
      (<pair22> ^4 <o4> ^6 <o6>)}
-{ (<p2> ^negpair <pair25>)
      (<pair25> ^5 <o5> ^6 <o6>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^6 <o6> + ^5 <o5> + ^4 <o4> + ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*8-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 8)
    (<p1> ^8 <o8> ^7 <o7> ^6 <o6> ^5 <o5> ^4 <o4> ^3 <o3> ^2 <o2> ^1 <o1>)
  -{ (<p2> ^neg <n8>)
      (<n8> ^8 <o8>)}
  -{ (<p2> ^neg <n7>)
      (<n7> ^5 <o7>)}
  -{ (<p2> ^neg <n6>)
      (<n6> ^6 <o6>)}
  -{ (<p2> ^neg <n5>)
      (<n5> ^5 <o5>)}
  -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
  -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^2 <o2>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^1 <o1> ^3 <o3>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^1 <o1> ^4 <o4>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^1 <o1> ^5 <o5>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^1 <o1> ^6 <o6>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^1 <o1> ^7 <o7>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^1 <o1> ^8 <o8>)}
-{ (<p2> ^negpair <pair8>)
      (<pair8> ^2 <o2> ^3 <o3>)}
-{ (<p2> ^negpair <pair9>)
      (<pair9> ^2 <o2> ^4 <o4>)}
-{ (<p2> ^negpair <pair10>)
      (<pair10> ^2 <o2> ^5 <o5>)}
-{ (<p2> ^negpair <pair11>)
      (<pair11> ^2 <o2> ^6 <o6>)}
-{ (<p2> ^negpair <pair12>)
      (<pair12> ^2 <o2> ^7 <o7>)}
-{ (<p2> ^negpair <pair13>)
      (<pair13> ^2 <o2> ^8 <o8>)}
-{ (<p2> ^negpair <pair14>)
      (<pair14> ^3 <o3> ^4 <o4>)}
-{ (<p2> ^negpair <pair15>)
      (<pair15> ^3 <o3> ^5 <o5>)}
-{ (<p2> ^negpair <pair16>)
      (<pair16> ^3 <o3> ^6 <o6>)}
-{ (<p2> ^negpair <pair17>)
      (<pair17> ^3 <o3> ^7 <o7>)}
-{ (<p2> ^negpair <pair18>)
      (<pair18> ^3 <o3> ^8 <o8>)}
-{ (<p2> ^negpair <pair21>)
      (<pair21> ^4 <o4> ^5 <o5>)}
-{ (<p2> ^negpair <pair22>)
      (<pair22> ^4 <o4> ^6 <o6>)}
-{ (<p2> ^negpair <pair23>)
      (<pair23> ^4 <o4> ^7 <o7>)}
-{ (<p2> ^negpair <pair24>)
      (<pair24> ^4 <o4> ^8 <o8>)}
-{ (<p2> ^negpair <pair25>)
      (<pair25> ^5 <o5> ^6 <o6>)}
-{ (<p2> ^negpair <pair26>)
      (<pair26> ^5 <o5> ^7 <o7>)}
-{ (<p2> ^negpair <pair27>)
      (<pair27> ^5 <o5> ^8 <o8>)}
-{ (<p2> ^negpair <pair28>)
      (<pair28> ^6 <o6> ^7 <o7>)}
-{ (<p2> ^negpair <pair29>)
      (<pair29> ^6 <o6> ^8 <o8>)}
-{ (<p2> ^negpair <pair30>)
      (<pair30> ^7 <o2> ^8 <o8>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^8 <o8> + ^7 <o7> + ^6 <o6> + ^5 <o5> + ^4 <o4> + ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*16-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 16)
    (<p1> ^8 <o8> ^7 <o7> ^6 <o6> ^5 <o5> ^4 <o4> ^3 <o3> ^2 <o2> ^1 <o1>
          ^9 <o9> ^10 <o10> ^16 <o16> ^15 <o15> ^14 <o14> ^13 <o13> ^12 <o12> ^11 <o11>)
 -{ (<p2> ^neg <n10>)
      (<n10> ^1 <o10>)}
  -{ (<p2> ^neg <n11>)
      (<n11> ^11 <o11>)}
  -{ (<p2> ^neg <n16>)
      (<n16> ^16 <o16>)}
  -{ (<p2> ^neg <n15>)
      (<n15> ^15 <o15>)}
  -{ (<p2> ^neg <n14>)
      (<n14> ^14 <o14>)}
  -{ (<p2> ^neg <n13>)
      (<n13> ^13 <o13>)}
   -{ (<p2> ^neg <n12>)
      (<n12> ^12 <o12>)}
   -{ (<p2> ^neg <n9>)
      (<n9> ^9 <o9>)}  
-{ (<p2> ^neg <n8>)
      (<n8> ^8 <o8>)}
  -{ (<p2> ^neg <n7>)
      (<n7> ^7 <o7>)}
  -{ (<p2> ^neg <n6>)
      (<n6> ^6 <o6>)}
  -{ (<p2> ^neg <n5>)
      (<n5> ^5 <o5>)}
  -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
  -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
   -{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^2 <o2>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^1 <o1> ^3 <o3>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^1 <o1> ^4 <o4>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^1 <o1> ^5 <o5>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^1 <o1> ^6 <o6>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^1 <o1> ^7 <o7>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^1 <o1> ^8 <o8>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^1 <o1> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^1 <o1> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^1 <o1> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^1 <o1> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^1 <o1> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^1 <o1> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^1 <o1> ^16 <o16>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^2 <o2> ^3 <o3>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^2 <o2> ^4 <o4>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^2 <o2> ^5 <o5>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^2 <o2> ^6 <o6>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^2 <o2> ^7 <o7>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^2 <o2> ^8 <o8>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^2 <o2> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^2 <o2> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^2 <o2> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^2 <o2> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^2 <o2> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^2 <o2> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^2 <o2> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^2 <o2> ^16 <o16>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^3 <o3> ^4 <o4>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^3 <o3> ^5 <o5>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^3 <o3> ^6 <o6>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^3 <o3> ^7 <o7>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^3 <o3> ^8 <o8>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^3 <o3> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^3 <o3> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^3 <o3> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^3 <o3> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^3 <o3> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^3 <o3> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^3 <o3> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^3 <o3> ^16 <o16>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^4 <o4> ^5 <o5>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^4 <o4> ^6 <o6>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^4 <o4> ^7 <o7>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^4 <o4> ^8 <o8>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^4 <o4> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^4 <o4> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^4 <o4> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^4 <o4> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^4 <o4> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^4 <o4> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^4 <o4> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^4 <o4> ^16 <o16>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^5 <o5> ^6 <o6>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^5 <o5> ^7 <o7>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^5 <o5> ^8 <o8>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^5 <o5> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^5 <o5> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^5 <o5> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^5 <o5> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^5 <o5> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^5 <o5> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^5 <o5> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^5 <o5> ^16 <o16>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^6 <o6> ^7 <o7>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^6 <o6> ^8 <o8>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^6 <o6> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^6 <o6> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^6 <o6> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^6 <o6> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^6 <o6> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^6 <o6> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^6 <o6> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^6 <o6> ^16 <o16>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^7 <o7> ^8 <o8>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^7 <o7> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^7 <o7> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^7 <o7> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^7 <o7> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^7 <o7> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^7 <o7> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^7 <o7> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^7 <o7> ^16 <o16>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^8 <o8> ^9 <o9>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^8 <o8> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^8 <o8> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^8 <o8> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^8 <o8> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^8 <o8> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^8 <o8> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^8 <o8> ^16 <o16>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^9 <o9> ^10 <o10>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^9 <o9> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^9 <o9> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^9 <o9> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^9 <o9> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^9 <o9> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^9 <o9> ^16 <o16>)}
-{ (<p2> ^negpair <pair7>)
      (<pair7> ^10 <o10> ^11 <o11>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^10 <o10> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^10 <o10> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^10 <o10> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^10 <o10> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^10 <o10> ^16 <o16>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^11 <o11> ^12 <o12>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^11 <o11> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^11 <o11> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^11 <o11> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^11 <o11> ^16 <o16>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^12 <o12> ^13 <o13>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^12 <o12> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^12 <o12> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^12 <o12> ^16 <o16>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^13 <o13> ^14 <o14>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^13 <o13> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^13 <o13> ^16 <o16>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^14 <o14> ^15 <o15>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^14 <o14> ^16 <o16>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^15 <o15> ^16 <o16>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^8 <o8> + ^7 <o7> + ^6 <o6> + ^5 <o5> + ^4 <o4> + ^1 <o1> + ^2 <o2> + ^3 <o3> +
          ^9 <o9> ^10 <o10> ^16 <o16> ^15 <o15> ^14 <o14> ^13 <o13> ^12 <o12> ^11 <o11>)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*4-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 4)
    (<p1> ^4 <o4> ^3 <o3> ^2 <o2> ^1 <o1>)
  -{ (<p2> ^neg <n4>)
      (<n4> ^4 <o4>)}
  -{ (<p2> ^neg <n3>)
      (<n3> ^3 <o3>)}
   -{ (<p2> ^neg <n2>)
      (<n2> ^2 <o2>)}
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
-{ (<p2> ^negpair <pair1>)
      (<pair1> ^1 <o1> ^2 <o2>)}
-{ (<p2> ^negpair <pair2>)
      (<pair2> ^1 <o1> ^3 <o3>)}
-{ (<p2> ^negpair <pair3>)
      (<pair3> ^1 <o1> ^4 <o4>)}
-{ (<p2> ^negpair <pair4>)
      (<pair4> ^2 <o2> ^3 <o3>)}
-{ (<p2> ^negpair <pair5>)
      (<pair5> ^2 <o2> ^4 <o4>)}
-{ (<p2> ^negpair <pair6>)
      (<pair6> ^3 <o3> ^4 <o4>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1>  ^4 <o4> + ^1 <o1> + ^2 <o2> + ^3 <o3> +)
}

sp {satisfy-predicate-conditions*elaborate*initial-set*1-arguments
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1>)
    (<p2> ^tested calculate6 ^argnum 1)
    (<p1> ^1 <o1>)
   -{ (<p2> ^neg <n1>)
      (<n1> ^1 <o1>)}
    -->
    (<p2> ^iset <i1> +)
    (<i1> ^1 <o1> +)
}

sp {satisfy-predicate-conditions*elaborate*negative-condition-instance*2-arguments
    (state <s1> ^gtype <c2> ^list <l1> ^<c2> <p1>)
    (<l1> ^game <g1>)
    (<p1> ^parameter-set <p2> ^potential-args <p3> ^condition <c1>)
    (<p2> ^tested calculate3)
    (<c1> ^parameter <p4> ^result <r1>)
    (<p4> ^num 2 ^2 <*1> ^1 <*2>) #not necessarily 1 and 2
    (<*1> ^param-id <x1>)
    (<*2> ^param-id <x2>)
    (<p3> ^<x2> <*3> ^<x1> <*4>)
   -{ (<r1> ^set <s2>)
      (<s2> ^instance <p5>)
      (<p5> ^2 <*4> ^1 <*3>)}
    -->
    (<p2> ^negpair <n1> +)
    (<n1> ^<x2> <*3> + ^<x1> <*4> +)
}

sp {satisfy-predicate-conditions*elaborate*negative-condition-instance*3-arguments
    (state <s1> ^gtype <c19> ^list <l1> ^<c19> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p1> ^potential-args <p2> ^condition <c1>)
    (<p1> ^tested calculate3)
    (<c1> ^parameter <p3> ^result <r1>)
    (<p3> ^num 3 ^3 <*1> ^2 <*2> ^1 <*3>) #not necessarily 1 and 2 and 3
    (<*1> ^param-id <ar2>)
    (<*2> ^param-id <ar1>)
    (<*3> ^param-id <ar3>)
    (<p2> ^<ar3> <*4> ^<ar2> <*5> ^<ar1> <*6>)
   -{ (<r1> ^set <s2>)
      (<s2> ^instance <p4>)
      (<p4> ^1 <*4> ^3 <*5> ^2 <*6>)}
    -->
    (<p1> ^negpair3 <n1> +)
    (<n1> ^<ar1> <*6> + ^<ar2> <*5> + ^<ar3> <*4> +)
}

sp {satisfy-predicate-conditions*elaborate*negative-condition-instance*1-argument
    (state <s1> ^gtype <c2> ^list <l1> ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^parameter-set <p2> ^potential-args <p1> ^condition <c1>)
    (<p2> ^tested calculate3)
    (<c1> ^parameter <p3> ^result <r1>)
    (<p3> ^<c6> <p4>)
    (<p4> ^param-id <c4>)
    (<p1> ^<c4> <o1>)
   -{ (<r1> ^set <s*1>)
      (<s*1> ^instance <p*1>)
      (<p*1> ^<c6> <o1>)}
    -->
    (<p2> ^neg <n1> +)
    (<n1> ^<c4> <o1> +)
}

sp {satisfy-predicate-conditions*elaborate*potential-argument*number
    (state <s1> ^gtype <c1> ^list <l1> ^<c1> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^condition <c3> ^potential-args <p1> ^parameter-set <p2>)
    (<c3> ^return-type number ^parameter <p3> ^result <r1> ^rtype single)
    (<r1> ^set <s2>)
    (<s2> ^instance <p5>)
    (<p3> ^<c4> <p4>) #tests existance of 1 to create possible of any
    (<p4> ^param-id <c6>) #^type single
    (<p5> ^<c4> <c7> ^1)
    -->
    (<p1> ^<c6> <c7> +)
}

sp {satisfy-predicate-conditions*elaborate*potential-argument
    (state <s1> ^gtype <c2> ^list <l1> ^<c2> <a1>)
    (<l1> ^game <g1>)
    (<a1> ^potential-args <p1> ^parameter-set <p2> ^condition <c1>)
    (<c1> ^parameter <p3> ^result <r1>)
    (<r1> ^set <s2>)
    (<s2> ^instance <p5>)
    (<p5> ^1 <o2> ^{ << 1 2 3 4 5 >> <c4> } <o1>) #tests existance of non empty 1 to create possible of any
   -{ (<o2> -^<wme> <w*1>)
      (<s1> ^list <l*1>)}
    (<p3> ^<c4> <p4>)
    (<p4> ^param-id <c6>)
    -->
    (<p1> ^<c6> <o1> +)
}
