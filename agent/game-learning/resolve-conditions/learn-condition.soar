sp {learn-condition*elaborate*conditions
   (state <s> ^name learn-condition
              ^superstate.operator.condition <co>)
-->
   (<s> ^condition <co>)
}

#temp if go back to retrieveal model may need to chunk here
sp {learn-condition*impasse
   (state <s> ^superstate.name learn-condition
              ^choices none
              ^attribute state
              ^superstate.condition <co>
              ^impasse no-change)
-->
   (<s> ^name learn-condition-impasse
        ^condition <co>)
}

sp {learn-condition-impasse*propose*with-attribute
   (state <s> ^name learn-condition-impasse
              ^superstate <ss>)
   (<ss> ^condition <co>)
   (<co> ^args <args> ^negative <bool> ^parameter <p> ^name <name> ^type attribute ^attribute <attr>)
   (<args> ^1 <a1>)
-->
   (<ss> ^operator <op> + =)
   (<op> ^args <args2>
         ^name with-attribute
         ^negative <bool>
         ^parameter <p>)
   (<args2> ^3 <a2> ^2 <a3> ^1 <a1>)
   (<a2> ^name number ^args <ag2> ^rtype single ^result.set.instance <a22> ^return-type number)
   (<a22> ^1 <attr>)
   (<a3> ^name number ^args <ag3> ^rtype single ^result.set.instance <a33> ^return-type number)
   (<a33> ^1 <name>)
}

sp {learn-condition-impasse*propose*with-attribute22
   (state <s> ^name learn-condition-impasse
              ^superstate <ss>)
   (<ss> ^condition <co>)
   (<co> ^args <args> ^negative <bool> ^parameter <p> -^name object ^name <name> ^type attribute ^attribute <attr>)
   (<args> -^1 <a1>)
-->
   (<ss> ^operator <op> + =)
   (<op> ^args <args2>
         ^name with-attribute
         ^negative <bool>
         ^parameter <p>)
   (<args2> ^3 <a2> ^2 <a3>)
   (<a2> ^name number ^args <ag2> ^rtype single ^result.set.instance <a22> ^return-type number)
   (<a22> ^1 <attr>)
   (<a3> ^name number ^args <ag3> ^rtype single ^result.set.instance <a33> ^return-type number)
   (<a33> ^1 <name>)
}

sp {learn-condition-impasse*propose*with-attribute*primitive-object
   (state <s> ^name learn-condition-impasse
              ^superstate <ss>)
   (<ss> ^condition <co>)
   (<co> ^args <args> ^negative <bool> ^parameter <p> ^name object ^type attribute ^attribute primitive)
   (<args> -^1 <a1>)
-->
   (<ss> ^operator <op> + =)
   (<op> ^args <args2>
         ^name with-attribute
         ^negative <bool>
         ^parameter <p>)
}

#normally here need to retrieve structure and elab linkstate predicate (already have)
sp {learn-condition-impasse*propose*top-pair
   (state <s> ^name learn-condition-impasse
              ^superstate <ss>)
   (<ss> ^condition <co>)
   (<co> ^args <args> ^negative <bool> ^parameter <p> ^name <name> ^type state-pair ^attribute <attr>)
-->
   (<ss> ^operator <op> + =)
   (<op> ^args <args>
         ^name top-pair
         ^type <name>
         ^attribute <attr>
         ^negative <bool>
         ^parameter <p>)
}

sp {learn-condition-impasse*propose*function
   (state <s> ^name learn-condition-impasse
              ^superstate <ss>)
   (<ss> ^condition <co>)
   (<co> ^args <args> ^negative <bool> ^parameter <p> ^name <name> ^type function ^function <func>)
-->
#    (interrupt)
   (<ss> ^operator <op> + =)
   (<op> ^args <args>
         ^name <func>
         ^type <name>
         ^negative <bool>
         ^parameter <p>)
}

#TODO JAMES when trying to generalize (notice that operators here have similar structure)
#TODO RECODE TODO
sp {learn-condition-impasse*propose*attribute-of
   (state <s> ^name learn-condition-impasse
              ^superstate <ss>)
   (<ss> ^condition <co>)
   (<co> ^args <args> ^negative <bool> ^parameter <p> ^name <type> ^type attribute-of)
 #  (<args> -^1 <a1>)
-->
   (<ss> ^operator <op> + =)
   (<op> ^args <args>
         ^name attribute-of
         ^type <type>
         ^negative <bool>
         ^parameter <p>)
}


sp {learn-condition-impasse*propose*has-attribute
   (state <s> ^name learn-condition-impasse
              ^superstate <ss>)
   (<ss> ^condition <co>)
   (<co> ^args <args> ^negative <bool> ^parameter <p> ^name <type> ^type has-attribute)
-->
   (<ss> ^operator <op> + =)
   (<op> ^args <args>
         ^name has-attribute
         ^type <type>
         ^negative <bool>
         ^parameter <p>)
}


sp {learn-condition-impasse*propose*same-attribute
   (state <s> ^name learn-condition-impasse
              ^superstate <ss>)
   (<ss> ^condition <co>)
   (<co> ^args <args> ^negative <bool> ^parameter <p> ^name <type> ^type same-attribute)
-->
 #  (write (cmd print <co> -d 9))
   (<ss> ^operator <op> + =)
   (<op> ^args <args>
         ^name same-attribute
         ^type <type>
         ^negative <bool>
         ^parameter <p>)
}



#TODO readd for reset up message
#sp {learn-condition*propose*retry-condition-setup*stillunrseolved
#   (state <s> ^operator.name wait
#              ^impasse no-change
#              ^superstate <sss>)
#   (<sss> ^name learn-condition)
#-->
#(<sss> ^operator <o> + >)
#(<o> ^name retry-condition-setup)
#}
#sp {learn-condition*propose*retry-condition-setup
#   (state <s> ^operator.name wait
#              ^impasse no-change
#              ^superstate.superstate <sss>)
#   (<sss> ^name learn-condition)
#-->
#(<sss> ^operator <o> + >)
#(<o> ^name retry-condition-setup)
#}


sp {retry-condition-setup*propose*complete
   (state <s> ^name retry-condition-setup)
-->
(<s> ^operator <o> + =)
(<o> ^name complete)
}

sp {retry-condition-setup*apply*complete
   (state <s> ^name retry-condition-setup
              ^quiescence t #do not chunk through this rule (failure case)
              ^top-state.dialog-context <dc>
              ^linkstate <ls>
              ^top-state <ts>
              ^top-state.interaction.changes <c>
              ^operator.name complete)
   (<ls> ^main-type <type> ^<type> <t> ^parsed-structure <ps>)
   (<t> ^nlp-set <nlp> ^formated)
(<dc> ^learn-link <ll>)
(<ll> ^argnum <an>)
-->
    (<ll> ^argnum <an> -)
    (<dc> ^needs-reset true)
    (<c> ^new-segment-info <info>)
   (<info> ^purpose <p>
           ^originator agent)
   (<p> ^type process-reset-state
        ^parameters.word <word>
        ^satisfaction <sat>)
   (<sat> ^dialog-event <de>)
   (<de> ^type single-word-response
          ^originator instructor)
   (<c> ^outgoing-message <out-msg>)
   (<out-msg> ^type reset-state
              ^complete-message true
              ^fields.word <type>)
   (<ps> ^learned-structure <nlp>)
}

#TODO ADD BACK FOR ISOMORPHIC DETECTION
#JK version
#sp {learn-condition*propose*auto-resolve-satisfaction-failure
#   (state <s> ^operator.name wait
#              ^impasse no-change
#              ^superstate.superstate <sss>)
#   (<sss> ^name learn-condition)
#-->
###(interrupt)
##(write (cmd print <sss> -d 6))
#(<sss> ^operator <o> + >)
#(<o> ^name auto-resolve-satisfaction-failure)
#}

# PR - my version
sp {learn-condition*propose*resolve-satisfaction-failure
   (state <s> ^operator.name wait
              ^impasse no-change
              ^superstate.superstate <sss>)
   (<sss> ^name learn-condition)
-->
(interrupt)
#(write (cmd print <sss> -d 6))
(<sss> ^operator <o> + >)
(<o> ^name resolve-satisfaction-failure)
}


sp {learn-condition*apply*resolve-satisfaction-failure
   (state <s> ^superstate <sss>)
   (<sss> ^name learn-condition
          ^operator.name resolve-satisfaction-failure)
-->
   (<s> ^unresolved-conditions <cos>
        ^set <out-cond>
        ^PR-game-details yes)
   (<out-cond> ^handle resolve-concept)
}

sp {resolve-satisfaction-failure*elaborate*unresolved
   (state <s> ^name resolve-satisfaction-failure
              ^superstate.superstate <sss>
              ^unresolved-conditions <cos>)
   (<sss> ^condition <co>)
   (<co> -^result.set.<x>)
-->
   (<cos> ^condition <co>)
}

# When the top condition is broken because of its child condition (e.g. on is broken because small block doesn't exist) add the child (missing small block) condition.
sp {resolve-satisfaction-failure*elaborate*select-bottom-most-conditions
   (state <s> ^name resolve-satisfaction-failure
              ^unresolved-conditions <cos>)
   (<cos> ^condition <co1>
          ^condition { <> <co1> <co2> })
   (<co1> ^args.<< 1 2 >> <co2>)
-->
   (<co1> ^added yes)
}

#PR - TODO this won't work in why not?
# When a concept is broken (larger-than, captured), the condition of the predicate appears unresolved as well. Only add the concept/link as unresolved condition.
sp {resolve-satisfaction-failure*elaborate*ignore-predicate-subcondition
   (state <s> ^name resolve-satisfaction-failure
              ^superstate.superstate.superstate <ssss>
              ^unresolved-conditions <cos>)
   (<cos> ^condition <co1>
          ^condition { <> <co1> <co2> })
   (<ssss> ^name evaluate-predicate
           ^predicate <pred>)
   (<pred> ^link <co2>
           ^condition <co1>)
-->
   (<co1> ^added yes)
}
   
sp {resolve-satisfaction-failure*propose*handle-unresolved-condition
   (state <s> ^name resolve-satisfaction-failure
              -^set.conditions
              ^unresolved-conditions <cos>)
   (<cos> ^condition <con>)
  -{ (<cos> ^condition {> <con> <con2>})} # Ensuring this operator is proposed only once given a set of conditions and it consists of at least one. 
-->
  # (interrupt)
   (<s> ^operator <o> +)
   (<o> ^name handle-unresolved-condition
        ^unresolved-conditions <cos>)
}

sp {resolve-satisfaction-failure*apply*add-condition-without-subconditions
   (state <s> ^name resolve-satisfaction-failure
              ^set <out-cond>
     		  ^quiescence t #do not chunk through this rule (failure case)
              ^operator <o>)
   (<o> ^name handle-unresolved-condition
        ^unresolved-conditions <cos>)
   (<cos> ^condition <co1>)
   (<co1> -^added yes)
-->
   (<s> ^PR-game-details yes
        ^new-set <new-set>)
   (<out-cond> ^conditions <co1>)
}

# If it has failed because a set was not satisfied but all conditions are satisfied.
sp {resolve-conditions*propose*resolve-satisfaction-failure
   (state <s> ^operator.name wait
              ^impasse no-change
              ^superstate <ss>
              ^superstate.superstate <sss>)
   (<ss> ^name resolve-conditions)
   (<sss> ^name chunk-predicate-impasse)
-->
   #(interrupt)
   (<ss> ^operator <o> + >)      
   (<o> ^name resolve-satisfaction-failure)
}

sp {resolve-conditions*elaborate*resolve-satisfaction-failure
   (state <s> #^name resolve-conditions
              ^superstate <ss>
              ^operator <o> +)
   (<o> ^name resolve-satisfaction-failure)
   (<ss> ^<gtype>.nlp-set <nlp-set>
         ^gtype { <> |predicate| <gtype> })
   (<nlp-set> ^<< nlp conditions >> <condition>)
   (<condition> ^args <args1>
                ^parameter <params1>)
-->
   (<condition> ^arg-count (size <args1>)
                ^param-count (size <params1>))
}
 
sp {resolve-conditions*elaborate*resolve-satisfaction-failure*select-nlp
   (state <s> ^name resolve-conditions
              ^superstate <ss>
              ^operator <o> +)
   (<o> ^name resolve-satisfaction-failure)
   (<ss> ^<gtype>.nlp-set <nlp-set>
         ^gtype { <> |predicate| <gtype> })
   (<nlp-set> ^<< nlp conditions >> <condition>)
   (<condition> #PR - TODO consider doing this with parameter instead of args
                ^args <args1>
                ^arg-count <argcount>)
   -{(<nlp-set> ^nlp { <condition2> <> <condition1> })
     (<condition2> ^arg-count { > <argcount> <argcount2> })}
-->
    (<o> ^nlp <condition>
         ^gtype <gtype>)
}

sp {dialog-event*elaborate*resolve-satisfaction-failure*select-nlp
   (state <s> ^name answer-can-you-see-game-concepts
              ^superstate <ss>
              ^operator <o> +)
   (<o> ^name resolve-satisfaction-failure)
   (<ss> ^<gtype>.nlp-set <nlp-set>
         ^gtype { <> |predicate| <gtype> }
         ^set <set>
         ) # PR - TODO not sure about this set here
   (<set> ^<gtype>)
   (<nlp-set> ^<< nlp conditions >> <condition>)
   (<condition> #PR - TODO consider doing this with parameter instead of args
                ^args <args1>
                ^arg-count <argcount>)
   -{(<nlp-set> ^<< nlp conditions >> { <condition2> <> <condition1> })
     (<condition2> ^arg-count { > <argcount> <argcount2> })}
-->
    (<o> ^nlp <condition>
         ^gtype <gtype>)
}

# Making the assumption that the result.set.instance has 2 args
# not considering multiple conditions with same no. of args yet
sp {resolve-conditions*apply*resolve-satisfaction-failure*neg-pair
   (state <s> ^name resolve-satisfaction-failure
              ^superstate <ss>
              ^superstate.superstate <sss>)
   (<ss> ^operator <o>)
   (<o> ^name resolve-satisfaction-failure
        ^nlp <cond>
        ^gtype <gtype>)
   (<cond> ^parameter <param>
           ^result.set.instance <inst>)
   (<param> ^1.param-id <paramid1>
            ^2.param-id <paramid2>)
   (<inst> ^1 <num> ^2 <cset>)
   (<sss> ^<gtype>.parameter-set.negpair <negpair>)
   (<negpair> ^<paramid1> { <num1> <> <num> } #num1 is what it should have been #PR - confirm with james
              ^<paramid2> <cset>)
-->
   (<s> ^set <set>
        ^new-set <new-set>
        ^PR-game-details yes)
   (<set> ^conditions <cond>
          ^handle resolve-concept)
}
# PR - end my  version

#case 3 inform instructor about condition not identified in the real world

sp {resolve-satisfaction-failure*propose*complete-handle-unresolved-condition
   (state <s> ^name resolve-satisfaction-failure
              ^PR-game-details yes
              ^generated <gen>
              ^added yes
              ^set <out-cond>
              ^descriptions <descs>)
-->
   (<s> ^operator <o> +)
   (<o> ^name complete-handle-unresolved-condition
        ^descriptions <descs>
        ^generated <gen>)   
}

# PR - TODO: complete this the way you complete can you see game concepts and remove unsatisfied condition from send-message
sp {resolve-satisfaction-failure*apply*complete-handle-unresolved-condition*condition-unsatisfied*remove-dialogue-context
   (state <s> ^name resolve-satisfaction-failure
              ^PR-game-details yes
              ^quiescence t #do not chunk through this rule (failure case)
              ^descriptions <descs>
              ^added yes
              ^generated <gen>
              ^set <out-cond>
              ^top-state <ts>
              ^top-state.interaction.changes <c> 
              ^operator <o>)
   (<o> ^name complete-handle-unresolved-condition)
   (<ts> ^dialogue-context <dc>)
-->
   (<ts> ^dialogue-context <dc> -) # remove dialogue-context if it exists from top-state (on answering why not?)
}
 
sp {resolve-satisfaction-failure*apply*complete-handle-unresolved-condition*condition-unsatisfied*send-message
   (state <s> ^name resolve-satisfaction-failure
              -^concept-seen
              -^purpose-type
              ^PR-game-details yes
              ^quiescence t #do not chunk through this rule (failure case)
              ^descriptions <descs>
              ^added yes
              ^generated <gen>
              ^set <out-cond>
              -^top-state.dialogue-context
              ^top-state.interaction.changes <c> 
              ^operator <o>)
   (<o> ^name complete-handle-unresolved-condition)
-->
   (<c> ^new-segment-info <info>)
   (<info> ^purpose <p>
           ^originator agent)
   (<p> ^type process-unsatisfied-condition
        ^parameters.condition <co>
        ^satisfaction <sat>)
   (<sat> ^dialog-event <de>)
   (<de> ^type single-word-response # PR - Additionally you could write extra rules (with type process-unsatisfied-condition in case instructor needs further detail about the issue or for clarifications.
          ^originator instructor)
   (<c> ^outgoing-message <out>)
   (<out> ^type unsatisfied-condition
          ^fields.descriptions <descs>)
}
# Alternate RHS for above. Right now, the above method ensures if there is an issue while learning a game, the execution continues
# Whereas in the following way, execution stops 
#   (<out> ^send-message <msg>)
#   (<msg> ^type unsatisfied-condition
#          ^fields.descriptions <descs>)

sp {resolve-satisfaction-failure*apply*complete-handle-unresolved-condition*concept-not-seen*send-message
   (state <s> ^name resolve-satisfaction-failure
              ^purpose-type <type>
              ^concept-seen <seen>
              ^gtype <gtype>
              ^operator <o>
              ^PR-game-details yes
              ^quiescence t #do not chunk through this rule (failure case)
              ^descriptions <descs>
              ^added yes
              ^generated <gen>
              ^set <out-cond>
              ^io.output-link <out>)
   (<o> ^name complete-handle-unresolved-condition)
-->
   (<out> ^send-message <msg>)
   (<msg> ^type <type>
          ^fields.response <res>)
   (<res> ^descriptions <descs>
          ^concept-seen <seen>
          ^gtype <gtype>)
}

sp {resolve-satisfaction-failure*apply*complete-handle-unresolved-condition*mark*performed
   (state <s> ^name resolve-satisfaction-failure
              ^quiescence t #do not chunk through this rule (failure case)
              ^operator.name complete-handle-unresolved-condition
              ^top-state <ts>)
   (<ts> ^interaction.status <status>)
-->
   (<status> ^performed.dialog-event <de>)
   (<de> ^type explanation
         ^originator agent)
}

#case 1
#could be because concept has another unknown definition

#case 2
#could be because concepts has another known definition

#case 3, bad argument connection

#case 4, description incorrect could list simplest condition could not satisfy
#only reach this case if ruled out 1 or 2

#case 5, got to isets, but there is a negpair case....

#would be useful application of preeti's work-> describing an unsatified concept in english= I could not find any matched objects, or i could not find a value of an object...

